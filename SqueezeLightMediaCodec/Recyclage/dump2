package gti310.tp4.utility;

public class Converter {




	/**
	 * Fonction qui crée un array AC a partir du array résultant du ZigZag
	 * @param ZigZagArray
	 * @return
	 */
	/*
	public static int[][][] createACArray(int[][][][] ZigZagArray){

		/*
		// boucler sur le tableau zigzag,
		// vérifier chacune des données sauf le 0,0
		composer des couples(nb repetition de zero, valeur)
		recombiner en array 3 dimension [espace][index][nbZero, valeur]
		*/
	/*	
		int nbBlock = ZigZagArray[0].length;
		int valeur = 0;
		int nbZeros = 0;
		int[] couple = new int[2];
		ArrayList<int[]> ar = new ArrayList<int[]>();

		int[][][] returnedACArrayAbusivementEnorme = new int[COLOR_SPACE_SIZE][20000][2];

		for (int i = 0 ; i < ZigZagArray.length; i++) { // boucler a travers les composantes
			ar.clear();
			valeur = 0;
			
			for (int v = 0; v < nbBlock; v++) { // boucler a travers les blocs verticaux identifiés -> Y
				for (int h = 0; h < nbBlock; h++) { // boucler a travers les blocs horizontaux -> X
					for (int j = 1; j < ZigZagArray[i][v][h].length-1; j++) {
						
						// on ignore le premier nombre et on identifie les nombre et on cree une paire (nb de zeros précédant, valeur )
						//96,6,-1,-1,0,-1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0
						//(0,6)(0,-1)(0,-1)(1,-1)(3,1)(2,1)
						valeur = ZigZagArray[i][v][h][j];
						
						if(valeur != 0){
							// il faut absolument ré-initialiser le array couple car il est passé en référence au arraylist
							// et ainsi a chaque ajout le contenu complet de l'arraylist change pour le nouveau couple
							// http://www.coderanch.com/t/580391/java/java/Vector-object-overwritten-adding-element
							couple = new int[2];
							couple[0] = nbZeros;
							couple[1] = valeur;
					
							ar.add(couple);
							nbZeros = 0;

						}
						else{
							nbZeros++;
						}
					}
				}
			}
			
		*/	
			/*
				on se retrouve avec 3 arrayLists
					Size	Mod
				Y	17011	17012
				Cb	4207	21215
				Cr	4437	25653
			*/
			/*	
			System.out.println("TO ARRAY");
		// selon l'énoncé, dans la méthode décriture du fichier, il semblerais que le AC doit pouvoir etre écrit en 8x8
			for (int j = 0; j < ar.size(); j++) {
				returnedACArrayAbusivementEnorme[i][j] = ar.get(j);
			}

		}
		
		return returnedACArrayAbusivementEnorme;
	}
*/
	
	
	
	
	//http://stackoverflow.com/questions/1067073/initialising-a-multidimensional-array-in-java
	/**
	 * Function that converts one RGBColor array into a YCbCrColor array
	 * @param color, an array {int RedValue, int GreenValue, int BlueValue}
	 * @return YCbCrResult, an array {float Y, float Cb, float Cr}
	 */
	public static float[] RGBToYCbCr(int Red, int Green, int Blue){
		float [] YCbCrResult = {0,0,0};
	/*			
		// Y = 0,299 R + 0,587 G + 0,114 B
		YCbCrResult[0] = (float) ((0.299 * Red) + (0.587 * Green) + (0.114 * Blue));  

		// Cb = (B-Y) / 1,772 + 0.5
		YCbCrResult[1] = (float) (((Blue - YCbCrResult[0]) / 1.772) + 0.5);
		
		// Cr = (R-Y) / 1,402 + 0.5
		YCbCrResult[2] = (float) (((Red - YCbCrResult[0]) / 1.402) + 0.5);
*/
		
		/*
		YCbCrResult[0] = (float) ((0.299 * Red) + (0.587 * Green) + (0.114 * Blue));  
		YCbCrResult[1] = (float) (-0.16874 * Red - 0.33126 * Green + 0.50000 * Blue);
		YCbCrResult[2] = (float) (( 0.50000 * Red - 0.41869 * Green - 0.08131 * Blue));
		*/
		
		YCbCrResult[0] = (float) Math.round( 0.299 * Red + 0.587 * Green + 0.114 * Blue); 
		YCbCrResult[1] = (float) Math.round(-0.16874 * Red - 0.33126 * Green + 0.50000 * Blue + 128); 
		YCbCrResult[2] = (float) Math.round( 0.50000 * Red - 0.41869 * Green - 0.08131 * Blue + 128);
		
		
		
		return YCbCrResult;
	}


	// sauce : https://msdn.microsoft.com/en-us/library/ff635267.aspx
	public static int[] YCbCrToRGB(float Y, float Cb, float Cr){
		int [] RGBResult = {0,0,0};

		RGBResult[0] = (int) ((Y*1) + (Cb*0) + (Cr*1.403));
		RGBResult[1] = (int) ((Y*1.0) + (Cb * -0.344) + (Cr * -0.714));
		RGBResult[2] = (int) ((Y*1.0) + (Cb * 1.77) + (Cr * 0));
		
	/*	
	  // verification pour ne pas depasser les valeurs max et min de la conversion.
	  // pas necessaire avec le système de conversion par multiplications
		RGBResult[0] = Math.max(0, Math.min(255, RGBResult[0]));
		RGBResult[1] = Math.max(0, Math.min(255, RGBResult[1]));
		RGBResult[2] = Math.max(0, Math.min(255, RGBResult[2]));
		 
	*/	
		return RGBResult;
	}
	
	
	
	
	public static void DCTconverter(float[][][] bloc){
		// manipuler un ensemble(bloc) de 8x8 pixel et applique le traitement de moyennes...
		
		
		
	}
	
	
	
	public static float C(int w){
		if(w == 0){
			return (float) (1/Math.sqrt( (double) 2 ));
		}
		return 1;
	}
	
	
	
}
